★オリジナルはカックさんのデモ。このデモをGSI版に変更した。結果はLSI版と同じ
https://github.com/kakakakakku/yosyosh-training-jupyter-notebooks/blob/master/developing33/mod6_dynamodb_lsi_wcu.ipynb

↓要するに、テーブル更新した内容がLSIの属性も含まれていたらテーブルとLSIの両方でWCUが消費されると書いてある
https://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/LSI.html

テーブル内の項目が追加、更新、または削除された場合にローカルセカンダリインデックスを更新すると、テーブルにプロビジョニングされた書き込みキャパシティーユニットが消費されます。書き込み用にプロビジョニングされたスループットの合計コストは、テーブルに対する書き込みと、ローカルセカンダリインデックスの更新で消費された書き込みキャパシティーユニットの合計になります。

インデックス付き属性を定義するテーブルに新しいアイテムを書き込んだ場合、
または既存のアイテムを更新して未定義のインデックス属性を定義する場合は、
アイテムをインデックスに入れるために 1 つの書き込み操作が必要です。

テーブルを更新すると、
インデックス付きキー属性の値が (A から B に) 変更された場合、2 つの書き込みが必要です。
1 つは前の項目をインデックスから削除し、もう 1 つは新しいアイテムをインデックスに配置するための書き込みです。 

インデックスに項目が存在したが、テーブルへの書き込みによってインデックス付き属性が削除された場合、
古いアイテムの射影をインデックスから削除するには、1 回の書き込みが必要です。

アイテムが更新される前または後にインデックス内にアイテムが存在しない場合、
インデックスの追加の書き込みコストは発生しません。
